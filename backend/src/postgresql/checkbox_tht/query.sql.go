// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package checkbox_tht

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (name, description, due_date)
VALUES ($1, $2, $3)
RETURNING id, name, description, due_date
`

type CreateTaskParams struct {
	Name        string             `json:"name"`
	Description string             `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
}

type CreateTaskRow struct {
	ID          int32              `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (CreateTaskRow, error) {
	row := q.db.QueryRow(ctx, createTask, arg.Name, arg.Description, arg.DueDate)
	var i CreateTaskRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DueDate,
	)
	return i, err
}

const deleteTask = `-- name: DeleteTask :one
DELETE
FROM tasks
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteTask(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteTask, id)
	err := row.Scan(&id)
	return id, err
}

const getPagedTasks = `-- name: GetPagedTasks :many
SELECT id, name, description, due_date, is_done, created_at
FROM tasks
WHERE (
    (CASE WHEN $3::boolean THEN is_done is NULL ELSE (is_done is NULL or is_done is Not null) END)
    AND (CASE WHEN $4::text = '' THEN true ELSE name_search @@ to_tsquery('english', $4) END)
    )
ORDER BY CASE
             WHEN NOT $5::boolean AND $6::text = 'due_date' THEN due_date
             END ASC,
         CASE
             WHEN NOT $5::boolean AND $6::text = 'id' THEN id
             END ASC,
         CASE
             WHEN $5::boolean AND $6::text = 'due_date' THEN due_date
             END DESC,
         CASE
             WHEN $5::boolean AND $6::text = 'id' THEN id
             END DESC
LIMIT $1 OFFSET $2
`

type GetPagedTasksParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Unchecked bool   `json:"unchecked"`
	Search    string `json:"search"`
	Reverse   bool   `json:"reverse"`
	OrderBy   string `json:"order_by"`
}

type GetPagedTasksRow struct {
	ID          int32              `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
	IsDone      pgtype.Timestamptz `json:"is_done"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetPagedTasks(ctx context.Context, arg GetPagedTasksParams) ([]GetPagedTasksRow, error) {
	rows, err := q.db.Query(ctx, getPagedTasks,
		arg.Limit,
		arg.Offset,
		arg.Unchecked,
		arg.Search,
		arg.Reverse,
		arg.OrderBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPagedTasksRow
	for rows.Next() {
		var i GetPagedTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DueDate,
			&i.IsDone,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPagedTasksByName = `-- name: GetPagedTasksByName :many
SELECT id, name, description, due_date
FROM tasks
WHERE name_search @@ to_tsquery('english', $1)
ORDER BY id
LIMIT $2 OFFSET $3
`

type GetPagedTasksByNameParams struct {
	ToTsquery string `json:"to_tsquery"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type GetPagedTasksByNameRow struct {
	ID          int32              `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
}

func (q *Queries) GetPagedTasksByName(ctx context.Context, arg GetPagedTasksByNameParams) ([]GetPagedTasksByNameRow, error) {
	rows, err := q.db.Query(ctx, getPagedTasksByName, arg.ToTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPagedTasksByNameRow
	for rows.Next() {
		var i GetPagedTasksByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalTasks = `-- name: GetTotalTasks :one
SELECT COUNT(*) AS total from tasks
WHERE (
          (CASE WHEN $1::boolean THEN is_done is NULL ELSE (is_done is NULL or is_done is Not null) END)
              AND (CASE WHEN $2::text = '' THEN true ELSE name_search @@ to_tsquery('english', $2) END)
          )
`

type GetTotalTasksParams struct {
	Unchecked bool   `json:"unchecked"`
	Search    string `json:"search"`
}

func (q *Queries) GetTotalTasks(ctx context.Context, arg GetTotalTasksParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalTasks, arg.Unchecked, arg.Search)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const toggleTaskDone = `-- name: ToggleTaskDone :one
UPDATE tasks
SET is_done = CASE WHEN is_done IS NULL THEN CURRENT_TIMESTAMP ELSE NULL END
WHERE id = $1
RETURNING id, name, description, due_date, is_done
`

type ToggleTaskDoneRow struct {
	ID          int32              `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
	IsDone      pgtype.Timestamptz `json:"is_done"`
}

func (q *Queries) ToggleTaskDone(ctx context.Context, id int32) (ToggleTaskDoneRow, error) {
	row := q.db.QueryRow(ctx, toggleTaskDone, id)
	var i ToggleTaskDoneRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DueDate,
		&i.IsDone,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET name        = $1,
    description = $2,
    due_date    = $3
WHERE id = $4
RETURNING id, name, description, due_date
`

type UpdateTaskParams struct {
	Name        string             `json:"name"`
	Description string             `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
	ID          int32              `json:"id"`
}

type UpdateTaskRow struct {
	ID          int32              `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (UpdateTaskRow, error) {
	row := q.db.QueryRow(ctx, updateTask,
		arg.Name,
		arg.Description,
		arg.DueDate,
		arg.ID,
	)
	var i UpdateTaskRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DueDate,
	)
	return i, err
}
